\chapter{Literature Review}
\label{litreview}

\section{Structures}

\subsection{Octrees}
\citeauthor{meagher80octree} first introduced the concept of the octree encoding in \cite{meagher80octree}, before expanding on it in \cite{meagher81octree}. \citeauthor{meagher81octree} presented the first homogeneous, generalisable data structure for 3D rendering, identifying the parallelisability of traversal and a variety of other operations on them.

\section{Ray tracing}
The earliest known application of ray tracing was by~\cite{appel68raytracing} in order to shade, as he called them, machine renderings of solids. Written long before the advent of real time computer graphics, some of the techniques \citeauthor{appel68raytracing}  pioneered, such as the use of light rays for determining when objects are in shadow, are still applicable today.

\cite{roth82roughimprove} presented an algorithm for directly rendering constructive solid geometry (CSG) without first computing spacial boundaries. \citeauthor{roth82roughimprove} described the calculation of eye rays for orthographic as well as perspective projections, as well as a hierarchical data structure for storing and rendering CSG directly. \citeauthor{roth82roughimprove} also described a number of primitives as well as the relevant necessary intersection tests. Additionally, \citeauthor{roth82roughimprove} demonstrated the application of this algorithm for producing realistically shaded solids for use in computer aided design, and also used shadow rays in order to produce ray traced shadows, and even described a method for anti-aliasing of the resulting image.

Roth's approaches allowed very broad geometric coverage in the surfaces they could render, as well as allowing the rendering of complex shapes in seconds.

\subsection{Space subdivision}
The next important advancement in ray casting technology was presented by~\cite{glassner84space}. By using an octree to partition space, storing a list of objects in each node of the tree, he greatly reduced the number of comparisons required for each ray. This allowed the rendering of hundreds, or even thousands of objects to be rendered in a scene without greatly increasing the computation time for each object. 

With this optimisation, \citeauthor{glassner84space}'s results showed that the rendering time now scaled with the number of rays that needed to be traced, rather than the number of objects in the scene as it previously additionally did \parencite{glassner84space}. The techniques pioneered by \citeauthor{glassner84space} reduced the rendering time of some of his more complex scenes by a factor of 20-30, and while real time rendering using this technique was still a long way off at this point, paved the way for renderers of the future to render complex scenes in linear time.

\subsection{Cone tracing}
\cite{amanatides84conetracing} highlights the limitations of ray tracing as a technique for producing realistic imagery due to its point-sampling nature. \citeauthor{amanatides84conetracing} presents a new method of ray tracing using cones rather than half-line rays in order to sample each pixel. The spread angle of the cone is chosen such that the radius of the cone's base is the size of the pixel according to the projection. \citeauthor{amanatides84conetracing} describes the necessary intersection calculations between a cone and various objects.

As cone tracing is no longer a point-sampling method, anti-aliasing is no longer required, and yet still only one ray per pixel is required. \citeauthor{amanatides84conetracing}' approach also allows for built in level of detail, soft shadows and blurred reflections.

\subsection{Distributed ray tracing}
\cite{cook84distributed} also provides a solution to these problems with traditional ray tracing. By distributing the directions of the rays according to the analytic functions they sample, \citeauthor{cook84distributed}'s approach allows ray tracing to render fuzzy phenomena. By utilising this technique, \citeauthor{cook84distributed} enable ray tracing to produce blurred reflections, translucency and soft shadows, motion blur and depth of field.

The advantages of this approach over \citeauthor{amanatides84conetracing}' cone tracing approach is that the ray intersection calculations do not change, merely the ray directions are distributed~\parencite{cook84distributed}. Similarly to \cite{amanatides84conetracing}, the approach presented in this paper also does not require any more rays than vanilla ray tracing. The disadvantage to this approach is that the rays are still point-sampled, and therefore, anti-aliasing techniques are still required in order to reduce the effects of aliasing on the edges of objects.

\subsection{Path tracing}
Shortly after \citeauthor{amanatides84conetracing} and \citeauthor{cook84distributed}'s approaches were published, a third approach was presented by~\cite{kajiya86therendering}. Kajiya's approach presents a single integral equation which generalises a variety of rendering techniques, along with a monte carlo solution for it. This equation has become known as "The Rendering Equation", the title of his 1986 paper. Solving it produces an accurate simulation of many effects, including soft shadows, depth of field, ambient occlusion, global illumination and motion blur. The physical basis to this equation is as an approximation to Maxwell's equation for electromagnetism, and to this day, solving this equation is the main challenge in realistic rendering~\parencite{dimov07numericalmethods}.

The disadvantage to \citeauthor{kajiya86therendering}'s approach is that a large number of rays must be traced in order to avoid noisy artifacts, increasing computation time significantly. Due to this, real-time path tracing has until recently been impossible.

\subsection{Ray cast optimisations}

\subsubsection{Dynamically sized ray step}
\cite{amanatides87afast} presents a significant optimisation to the traditional ray casting algorithm, by presenting a method of mathematically determining the next voxel in a traversal and automatically stepping directly to its boundary. Using this new algorithm, traversing from one voxel to its neighbour requires only two floating point comparisons and one floating point addition. This greatly reduces computation time for ray casts, and is the basis for a large amount of derivative work on efficient ray casting.

\cite{arvo88octreewalking} extends this technique to the octree, presenting an efficient linear-time voxel walking algorithm for octrees with a best case complexity of O(log N). \citeauthor{arvo88octreewalking}'s approach is a top-down approach which ensures that nodes are only considered once per ray and visits the voxels in the correct order, resulting in the O(log N) best case complexity. \citeauthor{arvo88octreewalking}'s algorithm involves checking the intersection of the ray with the root node of the octree, and recursively shortening the spans of the ray that are considered for intersection.

\subsubsection{Conversion of relevant data to a tree structure}
\cite{subramanian90applying} presents another new ray-tracing algorithm for volumes that is designed to work when the data of interest is sparsely distributed within the volume. It utilises a preprocessing step to determine which voxels represent features of interest, using this data to build a kd-tree. This tree is then efficiently ray-traced. The resultant tree is view-independent and can still be used if the camera or the lights move.

Although this approach is targeted towards converting raw volume data to a more efficiently ray traceable structure, it seems like it may be useful for application in games, where the original data is usually constructive solid geometry that we wish to export for use in-game. Nethertheless, the technique is unremarkable in this context.

\subsection{GPU implementation}
Due to the fact that ray tracing utilises one ray per pixel, a fact that both limits it and works to its advantage in its basic implementation, it should be obvious that the process is highly parallelisable. Additionally over the last decade, a breakthrough occurred in graphics hardware, which saw GPUs becoming massively parallel general-purpose stream processors, as opposed to the original fixed-function format. \cite{purcell02gpuraytracing} investigates this trend and explains how ray tracing can be mapped to graphics hardware. \citeauthor{purcell02gpuraytracing} demonstrate how to reformulate ray tracing as a streaming computation, making it appropriate for GPU implementation. The process is as follows:

% Hide number from itemize list item
\let\oldlabelitemi\labelitemi
\renewcommand{\labelitemi}{}

\begin{itemize}
	\item For each pixel of the screen:

	\begin{enumerate}
		\item Generate eye rays
		\item Traverse acceleration structure

			\begin{enumerate}
				\item Do intersection tests
			\end{enumerate}

		\item Shade hit

			\begin{enumerate}
				\item Generate shading rays (repeating 2-3 as necessary)
			\end{enumerate}

	\end{enumerate}
\end{itemize}

\citeauthor{purcell02gpuraytracing} were the first to demonstrate that efficient real-time ray tracing in the GPU is possible without any changes in architecture.

Additionally, and interestingly, in his 1981 paper, \citeauthor{meagher81octree} remarked on how parallelisable operations on octrees were.

% Restore old itemize list item style
\let\labelitemi\oldlabelitemi

\section{Efficient GPU traversal}
\cite{aila2009hpg} discusses the mapping of elementary ray tracing operations such as traversal and intersection onto GPUs. This work focuses on understanding the efficiency of GPU ray traversal rather than directly presenting an efficient ray traversal implementation, highlighting the fact that very little is understood about the performance of fast ray traversal algorithms. By comparing the performance of these algorithms against a theoretical upper bound, \citeauthor{aila2009hpg} demonstrate that previous methods are off by a factor of 1.5x - 2.5x theoretical optimal performance, and highlight previously unidentified inefficiencies in hardware work distribution.

Their work demonstrates that reliance on persistent threads rather than hardware work distribution mechanisms can improve the performance of the fastest GPU trace() kernels significantly.

\section{Hierarchical volume optimisations}

\subsection{Child voxel selection}
\cite{revelles00anefficient} presents an efficient parametric extension to \citeauthor{amanatides87afast}'s fast voxel traversal algorithm which significantly speeds up the traversal of octree data. The main difference to previous methods is related to descent within the tree, or in other words, the determining of which child voxel the ray enters first. \citeauthor{revelles00anefficient} greatly accelerate this computation using previously calculated parameter values for the ray. A similar method can also then be used for determining which neighbour voxel is next along the ray. These two modifications significantly accelerate the octree traversal process.

\subsection{Efficient octree storage}
\cite{wilhelms00octreesfor} present a space-efficient octree representation that does not allocate memory for empty space - what has become known as a sparse voxel octree (SVO). \citeauthor{wilhelms00octreesfor}'s structure utilises a pointerless "linear octree" structure which avoids storing pointers between every node.

\cite{laine10efficientsvos} expand on these ideas by storing pointers between blocks of octrees and otherwise determining a particular child's address using an index and a parent's 8-bit child mask. As the child's pointer can be obtained from a lookup table using this index and child mask, it is unnecessary to store a pointer for every voxel, making the structure far more efficient.

As \citeauthor{laine10efficientsvos} demonstrate, the SVO structure provides a structure that can be efficiently ray traced with an implicit LOD mechanism, as traversal can be terminated as soon as a found voxel is smaller than the current pixel on the screen. At high resolutions, however, even with the efficient SVO storage structure presented by \citeauthor{laine10efficientsvos}, mid-sized scenes still take up an excessive amount of storage, with \citeauthor{laine10efficientsvos}'s test scenes utilising up to 4GBs of memory, the upper bounds of memory on today's GPUs.

\cite{kampe2013dags} further extend on this idea by generalising the tree to a directed acyclic graph (DAG). While the SVO structure used in previous papers allows empty space to not be encoded, a DAG allows identical regions to share pointers. \citeauthor{kampe2013dags} have shown that with this technique, the memory usage on even highly irregular scenes is reduced by one to three orders of magnitude over an SVO.

\subsection{Packet traversal}
\cite{wald01interactiverendering} present a CPU-based parallel packet traversal algorithm which aims to utilise SIMD instructions in order to reduce the computation time by using SIMD instructions on multiple rays in parallel. Using this algorithm, they showed that a software ray tracer on a single PC could challenge rasterisation hardware for complex environments. \citeauthor{wald01interactiverendering} also demonstrate distributed ray tracing using multiple PCs outperforming rasterisation based graphics hardware.

\cite{gunther07bvhpacket} present a similar technique running in the GPU in an effort to fully exploit the capabilities of modern GPUs. \cite{gunther07bvhpacket} chose to use a shared stack rather than fully removing the stack, tracing packets of rays and share the stack storage with the whole packet. They also chose to use a BVH over other acceleration structures, noting that it was the only structure which allowed them to discard the per-ray entry and exit distances rather than having to store them onto a per-ray stack.

\subsection{Multi-level ray tracing}
\cite{reshetov05mrta} propose new approaches to ray tracing which reduce the required number of operations significantly while preserving the geometrical correctness of the solution. A hierarchical "beam" structure, representing a group of rays, is intersected with a kd-tree representing the whole scene in order to determine what parts of the kd-tree can be discarded from consideration. This allows for all of the rays inside the beam to begin traversal of the tree from some point deep inside the tree, rather than every ray having to traverse from the root of the tree. \citeauthor{reshetov05mrta} also note that the original beam can be further subdivided in order to continue looking for new entry points rather than being immediately decomposed into individual rays. The approach presented in \cite{reshetov05mrta} can therefore enable the ray tracing of extremely complex scenes by allowing traversal to start inside the tree.

\cite{laine10efficientsvos} adapt this approach to perform "beam optimisation" in their octree structure. By dividing the image into $4x4$ or $8x8$ pixel blocks and casting a distance ray for the corners of these blocks in the first pass, \citeauthor{laine10efficientsvos} present a method which guarantees that no important features are missed.

\cite{barczakunpublishedimproved} presents an alternative to \citeauthor{reshetov05mrta}'s entry-point search approach which eliminates traversals above and below the entry point node. \citeauthor{barczakunpublishedimproved} claims that this approach has a similar run-time cost, while generally eliminating more nodes, never eliminating fewer nodes.

\subsection{Dynamic bounding volumes}
\cite{wald07deformablebvh} presents a method of ray tracing deformable scenes efficiently using dynamic bounding volume hierarchies. For deformation based animation, while triangles are deformed they are generally not split or removed. For this reason, it is only necessary to refit the bounding volumes to the data from frame to frame. \citeauthor{wald07deformablebvh} present an efficient method for doing this while still performing comparably to ray tracing systems that can only accommodate static models.

\subsection{Contours}
\cite{laine10efficientsvos} presents a significant optimisation in the form of contours. "Contour" refers to a pair of parallel planes that provide a minimum bound for the volume's shape inside a voxel. By optionally storing a contour for each level of the tree and considering only the intersection of these contours as the shape of the voxel, the voxels are no longer limited to being only cubical. This results in a significant increase in detail with fewer levels of tree. If a contour is determined to be a good enough approximation to the original surface, subdivision is halted at the current level. Not only does this allow the data to be more detailed, but reduces the necessity for the data to be oversampled in order to present fine details.

\subsection{Animation}
Due to the nature of deformation, animation has previously not been possible with voxel structures because it would leave gaps between voxels. Additionally, deforming a hierarchical structure means that there is no longer a guarantee that all child nodes lie inside their parent nodes. \cite{bautembach2011animated} presents an approach to the animation of voxel octrees by expanding the parent voxels so that they still encompass all child voxels. \citeauthor{bautembach2011animated}'s approach demonstrates an efficient and effective approach character animation of voxel octrees, something which had previously been considered infeasible.

\section{Caching}
\cite{ruff13dynamiccaching} presents a caching-like strategy which is capable of storing data generated in previous frames which can then be used to accelerate rendering in later frames. \citeauthor{ruff13dynamiccaching} claim that their approach can be integrated to any existing ray tracing solution, and will allow data to be reused between frames. A significant limitation of this approach, however, is that it is tailored to static scenes. \citeauthor{ruff13dynamiccaching} point out that any movement of the scene objects would generate inconsistencies in cached data, although they do provide some potential solutions to this problem.