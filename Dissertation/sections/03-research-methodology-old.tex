\chapter{Methodology}
\label{methodology}

\section{Ray casting}
Our ray tracer uses the GPU-optimised parametric octree traversal algorithm presented by \cite{laine10efficientsvos}. This algorithm is extremely efficient for traversing along rays through a sparse octree as it hierarchically avoids empty space, finding the first intersection of the ray extremely fast.

Pseudocode for the ray casting algorithm is given in algorithm \ref{alg:raycast}. Push refers to advancing the traversal to the first entered voxel on the next level lower in the tree, while Advance refers to advancing the traversal to the next entered voxel on the current level. Pop is used to determine when the traversal has entered a different parent voxel in the case of advance. A full explanation of this algorithm is given in \cite{laine10efficientsvos}.

\subsection{Storage}
While extremely efficient to ray cast, and fairly compact when compared to previous SVO structures, \citeauthor{laine10efficientsvos}'s is still fairly heavy on memory usage. In their paper, \citeauthor{laine10efficientsvos} address this by only encoding surfaces, an approach that is obviously not possible if volumetric effects are desired. Additionally, they implement a concept called contours, in which surface voxels are restrained to a non-cubic shape using a pair of parallel planes, and once this shape provides a good enough approximation of the surface, the tree does not need to be generated any further. \citeauthor{laine10efficientsvos}'s implementation for this is very efficient, and automatically takes into account multiple levels of contours in order to produce a shape extremely close to the source data.

Additionally, more recent work by \citeauthor{kampe2013dags} has greatly reduced the memory usage of SVOs by allowing identical regions of the tree to share pointers, allowing the reuse of data between regions. \citeauthor{kampe2013dags} have found that, using this technique, the memory usage of even highly irregular scenes can be reduced by 1 to 3 orders of magnitude. These techniques should also be applicable to this work.

\section{Reflection and refraction rays}
Rays for reflection and refraction can be determined using Snell's law \parencite{glassner89introduction}. Given a normalised light vector $l$ which points from the light source towards the surface, and a normalised plane vector $n$, the reflection vector can be determined as follows \parencite{glassner89introduction}:

\[
v_{reflect} = 1 + 2cos\theta_1n
\]
\\
\centerline{where}
\[
	cos\theta_1 = -n \cdot l
\]

Similarly, the refracted ray's direction can be determined by considering the ratio of indices of refraction, $eta$ \parencite{glassner89introduction}:

\[
	v_{refract} = \frac{n_1}{n_2}l + (\frac{n_1}{n_2}cos\theta_1 - cos\theta_2)n
\]

Our ray tracer uses the implementation provided by the GLM C++ library. 

\section{Translucency}
In order to simulate translucency, it is necessary to cast a ray through a material in order to determine the transparency as well as to continue the ray tracing until the ray hits another surface. In addition, in order to support heterogeneous surfaces, it is necessary to consider differences in refractive indices as the ray travels through the material.

\citeauthor{laine10efficientsvos}'s efficient SVO traversal algorithm can be modified to cast a continuous ray through a material by redefining the exit condition from finding a voxel sufficiently small enough (or that is a leaf) to finding a voxel that is empty. This modification is demonstrated in algorithm \ref{alg:raycast_empty}.

This algorithm, while continuous in nature, has its limitations, however, as every level of SVO must be traversed as the ray passes through the material, resulting in the traversal's computational time scaling exponentially as the depth of the tree increases. As a compromise, we divide the ray into discrete steps and incrementally cast backwards along the ray using \citeauthor{laine10efficientsvos}'s original ray cast algorithm. This process is terminated once the resultant t value is non-zero, (in other words, when the ray does not originate inside a material,) at which time, it also returns the exit surface. Pseudocode for this process is given in algorithm \ref{alg:discrete_solid_cast}.

\section{Translucent heterogeneous materials}
Translucent heterogeneous materials, in other words materials with varying refractive indices or other attributes, can be ray traced in a similar way. By dividing the ray into discrete segments, the ray can be refracted between regions of varying refractive index to produce heterogeneous refraction.

Our implementation uses the ratio of the previous medium's refractive index, (1 for the primary ray as it is assumed to be cast through air,) to the next medium's refractive index in order to recalculate the direction of the refraction ray as it is traced at each discrete interval. A modified version of algorithm \ref{alg:discrete_solid_cast} that does this is provided in algorithm \ref{alg:discrete_heterogeneous_cast}.

Additionally, when the ray is refracting out of a medium rather than into it, the normal must be reversed from the normal which is usually used for rendering, as it is the normal of the plane through which the ray is refracting which must be considered when calculating a refraction ray. In order to determine this, we take the dot product of the current ray with the refraction boundary's normal and check if it is greater than zero, in other words if they are more than 180 degrees apart, and reverse the normal if so. This is shown in algorithm \ref{alg:discrete_heterogeneous_cast}.

\section{Shading}
Our shader uses a blinn-phong shading model, spawning secondary rays for shadows, reflection and refraction. A ray is cast towards each light source to check if it is occluded, in which case the intersection is in shadow. Reflection and refraction rays are then cast and the results are then mixed with the final output colour.

We use recursion to handle multiple levels of reflection and refraction to a predefined maximum. Simplified pseudocode for rendering and shading is given in algorithm \ref{alg:render}.

\section{Parallelisation}
Ray tracing is parallelised with one thread per pixel. This thread is then responsible for the primary ray and all secondary rays, as shown in algorithm \ref{alg:render}. These threads are spawned on the GPU in 32x32 grids to maximise occupancy. This is the maximum grid size on current generation CUDA GPUs, and allows us to achieve high levels of GPU utilisation as shown in chapter \ref{results}.

This approach allows us to achieve real-time rendering for simple scenes, and given the results of \cite{laine10efficientsvos} should also allow more complex scenes to be rendered. However, the limitation of this approach is that, as more work is added to each thread, every thread in a grid must follow the most computationally heavy computation path due to the highly parallelised nature of GPUs. Possible solutions to this problem are presented in chapter \ref{conclusion}.

\section{Test data}
Benchmarks for the software were taken by recording the average number of frames over a second (FPS) for a given screen resolution, as well as data resolution. Screen resolution is measured in pixels, while data resolution is measured in nodes of the tree at the lowest level of the tree. This resolution is given by the formula:

\[
	resolution = 2^{max\_scale~ -~ 1}
\]

Such that data generated down to the 11$^{th}$ level has a resolution of $2^{10} = 1024$ in each dimension. This is also referred to as a resolution of $1024^3$.

Each scene was tested across various screen resolutions as well as data resolutions in order to demonstrate how the algorithms scale with respect to screen resolution and data resolution.

Each scene at each resolution was also be recorded visually in order to determine the effect of voxelisation on visual image quality.

These tests were conducted on a single Nvidia GTX 670.