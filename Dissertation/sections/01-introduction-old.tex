\chapter{Old Introduction}
\label{intro}

\section{Aim}
This project aims to investigate the simulation of volumetric effects, such as refraction through heterogeneous materials, with in-GPU real-time volume ray tracing.

\section{Rasterisation}
Rasterisation is currently the most popular technique for producing real-time 3D computer graphics. It involves the tessellation of surfaces into triangles, which are then rendered to the screen by means of rasterisation. Each pixel is then shaded using an approximation of how light would be reflected off of each surface.

A key limitation of rasterisation as a rendering technique is that it only considers one polygon at any one time, which makes it impossible to do global effects such as global illumination and determining shadow coverage by pure rasterisation alone.

Another key limitation of rasterisation, and more generally using polygons to represent 3D data, is that only surface data can easily be encoded. This makes it impossible to simulate true volumetric effects such as refraction through heterogeneous materials.

\section{Marching cubes}
Although traditional rasterisation can not be used to directly render volume data, a technique called marching cubes, pioneered by \cite{lorensen87marchingcubes}, can be used in order to convert volume data into polygon meshes which can then be rasterised.

While this allows the rendering of volume data, marching cubes still only considers the surface of a volume, so does not allow us to simulate volumetric effects directly.

\section{Ray casting}
Ray casting, a technique pioneered by \cite{appel68raytracing}, on the other hand aims to simulate the path of light by casting a ray, known as an eye ray, from the eye to the surface in order to determine visibility \parencite{appel68raytracing}. This simulates the path of light in reverse, as in nature light follows the path from a light source to the surface before being reflected to the eye of an observer. By following the reverse of this ray, a physically accurate representation of this scene can be produced with a finite number of rays.

Additionally, although ray casting can be applied to polygon data, it is also applicable to any data with which an intersection test can be devised. As such, ray casting can be used to directly render 3D volume data, without having to convert it to polygons with an intermediate step.

\subsection{Method}
Although numerous works have expanded on and optimised the technique, the main steps are as follows.

% Hide number from itemize list item
\let\oldlabelitemi\labelitemi
\renewcommand{\labelitemi}{}

\begin{itemize}
	\item For each pixel of the screen:

	\begin{enumerate}
		\item Calculate a ray from the viewer through the near-view plane
		\item Find the nearest intersection of this ray with the scene
		\item Pass details of this intersection to a shader to be shaded
	\end{enumerate}
\end{itemize}

% Restore old itemize list item style
\let\labelitemi\oldlabelitemi

The shading can then be accomplished using the same techniques used in rasterisation, or by recursively spawning new rays to account for reflection, refraction, and also to check for whether a light source is directly visible in order to determine shadow coverage, a technique known as Ray Tracing.

\subsection{Ray tracing}
Ray tracing extends the ray casting technique by spawning secondary rays from points of intersect in order to determine reflected light, refracted light, and shadow coverage. This can be accomplished by recursively spawning rays whilst shading.

In addition, since ray casting can be applied to volume data, it is also possible to cast a ray through a volume, rather than just at or between surfaces, and therefore simulate true volumetric effects.

\subsubsection{Scaling}
Simple rasterisation and ray casting with polygons scale linearly with the number of polygons, as each polygon must be processed individually.

Even with techniques such as occlusion culling, which reduce the amount of the scene that rasterisation must process by determining surfaces which can not be visible, the rendering time for rasterisation increases linearly with the detail as smaller and more polygons must be added to produce more detail. Despite this, polygons do have an advantage for large surfaces with little detail, as a polygon of any size can be rasterised.

Space subdivision techniques however have been applied to ray casting such as \cite{glassner84space}, which uses an octree, (a structure which was presented by \cite{meagher80octree} as a structure for representing 3D space hierarchically, and that will be examined later in the section,) in order to subdivide space, reducing the number of polygons a particular ray must be checked for intersection with. Although this is an effective technique for speeding up the ray casting of large numbers of polygons, some researchers have questioned whether it would not be better to encode the volumes directly using these structures and have investigated means to efficiently do so \parencite{laine10efficientsvos}.

\subsection{Volumetric structures}

\subsubsection{Non-hierarchical structures}
The primary non-hierarchical structure which is used to encode volume data is the 3D array. The 3D array has some advantages as a simple data structure. It is simple to cast rays through intuitively, as the data within is laid out in a simple grid. Additionally, this structure may be suitable for where the data does not need to be a particularly high resolution, or for data of a fixed resolution where adaptively changing the resolution of the data does not provide any benefit.

Despite its advantages as a simple data structure, the array has some major limitations. Firstly, empty space is encoded using the same amount of storage as non-empty space. Generally, no attributes need to be stored to describe empty space, so it makes sense to not encode it if possible. Additionally, as previously suggested, the resolution is fixed so data containing regions of high detail must be stored entirely at a higher resolution. This causes this approach to have a much higher memory footprint than necessary.

\subsubsection{The octree}

The octree is a structure proposed by \cite{meagher81octree} which stores data hierarchically by dividing space into eight octants at each level in the hierarchy. In other words, space is divided once along each axis to produce $2^3 = 8$ octants.

This structure provides numerous advantages which will be discussed in section \ref{litreview}, but the major property of interest to us is the efficiency at which rays can be cast against it. \cite{revelles00anefficient} presents an efficient parametric algorithm for octree traversal which uses already computed parameter values in order to efficiently select the child voxel first entered by the ray. \cite{laine10efficientsvos} extends this work with an extremely efficient GPU implementation, which has been shown to exhibit similar performance to the fastest triangle ray casters, rendering complex scenes in real-time.